addiu_1:Add positive numbers: 0x10080000 and 0x3092
addiu_2:Add positive (0x1) and negative (0xffffffff or -1) to output 0
addiu_3:Add positive (0x1) and negative (0xfffffffe or -2) to output negative (0xffffffff or -1)
addiu_4:Add numbers in lower 16 bits: 0x1672 and 0x8172
addiu_5:Add 0x1672 and 0x3892
addiu_sanity_1
addiu_t0:Add to $0 should not change $0
addu_1:Load $4 and $5 with 0xFFFE0000 and 0x1 respectively. Add $4 and $5 into $2.
addu_2:Add negative numbers: 0xffffffff and 0xffffffff
addu_3:Add positive numbers: 0x1234 and 0x5678
addu_4:Add negative number to $0
addu_5:Add positive and negative numbers
and_1:And 0xffffa5a5 and 0x5a6a
and_2:And with 0 results in 0
and_3:And 0xffffffff with itself to test all 32 bits
and_4:And with 0xffffffff should not change the other register value
and_5:And with 0xfffff000 should mask out least significant 12 bits
andi_1:And 0x1aaa with 0x5555. And again with 0xdddf
andi_2:And 0xffffffff with 0x0000
andi_3:And 0xffffffff with 0xffffffff
andi_4:And 0x8000 with 0xffffffff
andi_5:And 0x1010 with 0x0101
beq_1:Test it branches when equal
beq_2:Test it doesn't branch when not equal
beq_3:Test branch comparison with the same register results in a branch
beq_4:Test branch comparison between 2 different registers with same value
beq_5:Test branch comparison between 0xffffffff and 0x0000ffff results in no branch
beq_fib_1:Find the 10th Fibonacci term
beq_finder:Search through a list of 10 integers and find 0, return the index
bgez_1:Test branch comparison: 0x00ff0000 > 0x0
bgez_2:Test branch when greater than 0: 1 > 0
bgez_3:Test it branches when equal to 0
bgez_4:Test it does not branch when less than 0
bgez_5:Test branching backwards
bgezal_1:Test branch works for greater than 0
bgezal_2:Test link register $31 updates correctly by moving value to $2
bgezal_3:Test branch works for equal to 0
bgezal_4:Test it doesn't branch when less than 0
bgezal_5:Test it can branch backwards
bgtz_1:Test it doesn't branch when equal to 0
bgtz_2:Test it branches when greater than 0
bgtz_3:Test it doesn't branch when equal to 0 and that registers are initialised to 0
bgtz_4:Test it doesn't branch when less than 0
bgtz_5:Test branching backwards
blez_1:Test it branches when less than zero
blez_2:Test it doesn't branch when greater than 0
blez_3:Test it branches when equal to 0
blez_4:Test it doesn't branch for value 0xffffffff
blez_5:Test branching backwards
bltz_1:Test it doesn't branch when greater than 0 for value 0x10
bltz_2:Test it doesn't branch when greater than 0 for value 0x1
bltz_3:Test it doesn't branch when equal to 0
bltz_4:Test it branches when less than 0
bltz_5:Test branching backwards
bltzal_1:Branch when negative
bltzal_2:No branch when equal to 0
bltzal_3:No branch when positive
bltzal_4:Test link register works
bltzal_5:Branch backwards
bne_1:Test it branches when not equal for 0xaa and 0xab
bne_2:Test it branches when not equal for 0x0 and 0x1
bne_3:Test it doesn't branch when they are equal (both zero)
bne_4:Test it branches when comparing 0xffffffff and 0x0000ffff
bne_5:Test branching backwards
bnez_binseq:Shift left 15 times using bnez to branch back
div_1:Divide 10/5 should result in lo=2
div_2:Divide 11/5 should result in lo=2
div_3:Divide 0xb0000 by 0x50000 should result in hi=0x10000
div_4:Divide 5/10 should result in lo=0
div_5:Dividing by -1 results in 0 remainder
divu_1:Test division with remainder, results in correct quotient
divu_2:Test division between 2 different halfs of word (larger division)
divu_3:Test division with large quotient
divu_4:Test complex division remainder
divu_5:Test division with no remainder has hi=0
j_1:Test jumping forwards
j_2:Test jumping backwards
jal_1:Test jumping forwards
jal_2:Test jumping backwards
jalr_1:Test jumping forwards
jalr_2:Test jumping backwards
jr_1:Test jumping forwards
jr_2:Test jumping backwards
jr_sanity_1:
lb_1:Loading least significant byte by storing and loading from same effective address
lb_2:Loads the byte after the most significant byte by adding 0x8 to the address offset in which the word was stored
lb_3:Test storing negative number and loading byte from unaligned address
lb_4:Test loading least significant byte of 0xfffd0000 from unaligned address 
lbu_1:Load byte after most significant byte 
lbu_2:Load byte after most significant byte from word aligned at address 0xc
lbu_3:Load byte from negative number
lh_1:Load negative half word
lh_2:Load second half of word
lh_3:Load first half of 0xfffd0000 to make sure word is stored correctly
lh_4:Load second half of 0xfffd0000
lhu_1:Load first half of positive number
lhu_2:Load second half of word
lhu_3:Load second half of negative number 0xfffd0000
lui_1:Load many positive numbers and add them
lui_2:Load 0x703a
lui_3:Load 0xffff
lw_1:Load word into address 0xc($9), where 0x7bcd is in $9
lw_2:Load word with data in most significant 2 bytes
lw_3:Load negative number in most significant 2 bytes
lw_4:Load byte from negative word, store it, and then load entire word
lwl_1:
lwl_2:
lwl_3:
lwl_4:
lwr_1:
lwr_2:
lwr_3:
lwr_4:
lw_sanity_2:
lw_sanity_3:
mfhi_1:
mfhi_2:
mfhi_3:
mfhi_4:
mfhi_5:
mflo_1:
mflo_2:
mflo_3:
mflo_4:
mflo_5:
mflo_t0:Test that moving lo register value to $0 does not change $0
mthi_1:
mthi_2:
mthi_3:
mthi_4:
mtlo_1:
mtlo_2:
mtlo_3:
mtlo_4:
mtlo_5:
mult_1:
mult_2:
mult_3:
mult_4:
mult_5:
mult_factorial:Find factorial of 5
multu_1:
multu_2:
multu_3:
multu_4:
multu_5:
or_1:
or_2:
or_3:
or_4:
or_5:
ori_1:
ori_2:
ori_3:
ori_4:
ori_5:
sb_1:
sb_2:
sb_3:
sb_4:
sb_5:
sh_1:
sh_2:
sh_3:
sh_4:
sh_5:
sll_1:
sll_2:
sll_3:
sll_4:
sll_5:
sll_6:
sll_7:
sll_power:Shifts 2 to the left 4 times
sll_sanity_1:
sll_sanity_7:
sllv_1:
sllv_2:
sllv_3:
sllv_4:
sllv_5:
sllv_6:
sllv_7:
slt_1:
slt_2:
slt_3:
slt_4:
slt_5:
slti_1:
slti_2:
slti_3:
slti_4:
slti_5:
sltiu_1:
sltiu_2:
sltiu_3:
sltiu_4:
sltiu_5:
sltu_1:
sltu_2:
sltu_3:
sltu_4:
sltu_5:
sra_1:
sra_2:
sra_3:
sra_4:
sra_5:
srav_1:
srav_2:
srav_3:
srav_4:
srl_1:
srl_2:
srl_3:
srl_4:
srl_5:
srlv_1:
srlv_2:
srlv_3:
srlv_4:
subu_1:
subu_2:
subu_3:
subu_4:
subu_5:
sw_1:
sw_2:
sw_3:
sw_4:
sw_5:
sw_sanity_1:
sw_sanity_2:
sw_sanity_3:
xor_1:
xor_2:
xor_3:
xor_4:
xor_5:
xori_1:
xori_2:
xori_3:
xori_4:
xori_5:
xori_pseudo:Solves equation involving xori, multiplication and addition
