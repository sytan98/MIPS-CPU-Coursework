addiu_1:Add positive numbers: 0x10080000 and 0x3092
addiu_2:Add positive (0x1) and negative (0xffff or -1) to output 0
addiu_3:Add positive (0x1) and negative (0xfffe or -2) to output negative (0xffff or -1)
addiu_4:Add numbers in lower 16 bits: 0x1672 and 0x8172
addiu_5:Add 0x1672 and 0x3892
addiu_sanity_1
addiu_t0:Add to $0 should not change $0
addu_1:Load $4 and $5 with 0xFFFE0000 and 0x1 respectively. Add $4 and $5 into $2.
addu_2:Add negative numbers: 0xffffffff and 0xffffffff
addu_3:Add positive numbers: 0x1234 and 0x5678
addu_4:Add negative number to $0
addu_5:Add positive and negative numbers
and_1:And 0xffffa5a5 and 0x5a6a
and_2:And with 0 results in 0
and_3:And 0xffffffff with itself to test all 32 bits
and_4:And with 0xffffffff should not change the other register value
and_5:And with 0xfffff000 should mask out least significant 12 bits
andi_1:And 0x1aaa with 0x5555. And again with 0xdddf
andi_2:And 0xffffffff with 0x0000
andi_3:And 0xffffffff with 0xffffffff
andi_4:And 0x8000 with 0xffffffff
andi_5:And 0x1010 with 0x0101
beq_1:Test it branches when equal
beq_2:Test it doesn't branch when not equal
beq_3:Test branch comparison with the same register results in a branch
beq_4:Test branch comparison between 2 different registers with same value
beq_5:Test branch comparison between 0xffffffff and 0x0000ffff results in no branch
beq_fib_1:Find the 10th Fibonacci term
beq_finder:Search through a list of 10 integers and find 0, return the index
bgez_1:Test branch comparison: 0x00ff0000 > 0x0
bgez_2:Test branch when greater than 0: 1 > 0
bgez_3:Test it branches when equal to 0
bgez_4:Test it does not branch when less than 0
bgez_5:Test branching backwards
bgezal_1:Test branch works for greater than 0
bgezal_2:Test link register $31 updates correctly by moving value to $2
bgezal_3:Test branch works for equal to 0
bgezal_4:Test it doesn't branch when less than 0
bgezal_5:Test it can branch backwards
bgtz_1:Test it doesn't branch when equal to 0
bgtz_2:Test it branches when greater than 0
bgtz_3:Test it doesn't branch when equal to 0 and that registers are initialised to 0
bgtz_4:Test it doesn't branch when less than 0
bgtz_5:Test branching backwards
blez_1:Test it branches when less than zero
blez_2:Test it doesn't branch when greater than 0
blez_3:Test it branches when equal to 0
blez_4:Test it doesn't branch for value 0xffffffff
blez_5:Test branching backwards
bltz_1:
bltz_2:
bltz_3:
bltz_4:
bltz_5:
bltzal_1:
bltzal_2:
bltzal_3:
bltzal_4:
bltzal_5:
bne_1:
bne_2:
bne_3:
bne_4:
bne_5:
bnez_binseq:
div_1:
div_2:
div_3:
div_4:
div_5:
divu_1:
divu_2:
divu_3:
divu_4:
divu_5:
j_1:
j_2:
jal_1:
jal_2:
jalr_1:
jalr_2:
jr_1:
jr_2:
jr_sanity_1:
lb_1:
lb_2:
lb_3:
lb_4:
lbu_1:
lbu_2:
lbu_3:
lh_1:
lh_2:
lh_3:
lh_4:
lhu_1:
lhu_2:
lhu_3:
lui_1:
lui_2:
lui_3:
lw_1:
lw_2:
lw_3:
lw_4:
lwl_1:
lwl_2:
lwl_3:
lwl_4:
lwr_1:
lwr_2:
lwr_3:
lwr_4:
lw_sanity_2:
lw_sanity_3:
mfhi_1:
mfhi_2:
mfhi_3:
mfhi_4:
mfhi_5:
mflo_1:
mflo_2:
mflo_3:
mflo_4:
mflo_5:
mflo_t0:
mthi_1:
mthi_2:
mthi_3:
mthi_4:
mtlo_1:
mtlo_2:
mtlo_3:
mtlo_4:
mtlo_5:
mult_1:
mult_2:
mult_3:
mult_4:
mult_5:
mult_factorial:
multu_1:
multu_2:
multu_3:
multu_4:
multu_5:
or_1:
or_2:
or_3:
or_4:
or_5:
ori_1:
ori_2:
ori_3:
ori_4:
ori_5:
sb_1:
sb_2:
sb_3:
sb_4:
sb_5:
sh_1:
sh_2:
sh_3:
sh_4:
sh_5:
sll_1:
sll_2:
sll_3:
sll_4:
sll_5:
sll_6:
sll_7:
sll_power:
sll_sanity_1:
sll_sanity_7:
sllv_1:
sllv_2:
sllv_3:
sllv_4:
sllv_5:
sllv_6:
sllv_7:
slt_1:
slt_2:
slt_3:
slt_4:
slt_5:
slti_1:
slti_2:
slti_3:
slti_4:
slti_5:
sltiu_1:
sltiu_2:
sltiu_3:
sltiu_4:
sltiu_5:
sltu_1:
sltu_2:
sltu_3:
sltu_4:
sltu_5:
sra_1:
sra_2:
sra_3:
sra_4:
sra_5:
srav_1:
srav_2:
srav_3:
srav_4:
srl_1:right shift 0xabc00000 >> 0x8
srl_2:right shift 0xffffffff >> 0x10 
srl_3:right shift 0x00001004 >> 0x1f (max shift) -> output is 0
srl_4:right shift 0xf00f0000 >> 0x1f (max shift)
srl_5:right shift 0xfaaaa0b3 >> 0x1e
srlv_1:right shift 0xabcd0000 >> 2 (register's value) 
srlv_2:right shift 0x78880000 >> 0xfffff010 (check it keeps the 5 LSBs)
srlv_3:right shift 0xffff0000 >> 0xffffabdf (check it keeps the 5 LSBs)
srlv_4:rigth shift 0xffff0000 >> 0x00000bdf (check it keeps the 5 LSBs)
subu_1:subtracting 0xabcd0000 from 0xffff0000 
subu_2:subtracting 0x00004321 from 0xffffffff
subu_3:subtracting 0xffffffff from 0 -> result is the absolute value of signed 0xffffffff
subu_4:subtracting 0x1 from 0 -> result is negative -1 (0xffffffff) 
subu_5:subtracting 0xfffff0aa from 0xfffff001
sw_1:storing 0x01050000 at mem[0xac (immediate) + 0x1bfc0000 (register value)]
sw_2:storing 0x0105 at mem[0xac (immediate) + 0x1bfc (register value)]
sw_3:storing 0xffffffff at mem[0xaa0 (immediate) + 0x1bfc0000 (register value)]
sw_4:storing (0x0-0x105) at mem[0xac3 (immediate) + 0x105 (register value)]
sw_5:storing (0x105*0xfffff001)[31:0] at mem[0xac8 (immediate) + 0x0 (register value)]
sw_sanity_1:
sw_sanity_2:
sw_sanity_3:
xor_1:xor 0xabcd with 0xf0f0
xor_2:xor 0x1010 with 0x1010 
xor_3:xor 0xffffffff with 0x00001234
xor_4:xor 0x0fff with 0 -> no change
xor_5:xor 0xfffff00f with 0xfffff00f
xori_1:xor (0xabcd0000^0xf0f00000)^0xffffffff -> all bits of first xor operation inverted
xori_2:xor 0x0123 with 0 -> no change
xori_3:xor 0xffff000 with 0x00000fff
xori_4:xor 0x0101 with 0x1010
xori_5:xor 0xffffabcd with 0xffffdabc (checking immediate sign-extension)
xori_pseudo:
